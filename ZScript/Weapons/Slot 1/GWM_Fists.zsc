class GWM_Fists : GWM_WeaponBase replaces Fist
{
	int raisespeed;
	int lowerspeed;
	property raisespeed : raisespeed;
	property lowerspeed : lowerspeed;

	//Pointers to states:
	protected state s_ready;
	protected state s_readyRight;
	protected state s_readyLeft;
	protected state s_fireRight;
	protected state s_fireLeft;
	protected state s_holdRight;
	protected state s_holdLeft;

	// Aliases for gun overlays
	enum FireLayers
	{
		PSP_RIGHTGUN = 5,
		PSP_LEFTGUN = 6
	}

	enum SoundChannels
	{
		CHAN_RIGHTGUN	= 12,
		CHAN_LEFTGUN = 13
	}

	// Set pointers to states here:
	override void PostBeginPlay()
	{
		super.PostBeginPlay();
		s_ready = FindState("Ready");
		s_readyRight = FindState("Ready.Right");
		s_readyLeft = FindState("Ready.Left");
		s_fireRight = FindState("Fire.Right");
		s_fireLeft = FindState("Fire.Left");
		s_holdRight = FindState("Hold.Right");
		s_holdLeft = FindState("Hold.Left");
	}

	/*	This is meant to be called instead of A_WeaponReady() in the main
		Ready state sequence (NOT in the left/right ready sequences).
		This doesn't actually make the weapon ready for firing directly, but
		rather	makes sure everything is set up correctly and creates overlays
		if they haven't been created yet.
		It also initiates reloading.
	*/
	action void DualWeaponReady()
	{
		// Don't let the weapon function if you're missing require state sequences:
		if (!invoker.s_readyRight || !invoker.s_readyLeft || !invoker.s_fireRight || !invoker.s_fireLeft)
		{
			console.printf("Can't function: some of the primary state labels in this weapon are missing.");
			A_WeaponReady(WRF_NOFIRE);
			return;
		}

		// Create gun overlays (once) if they're not drawn for some reason:
		A_Overlay(PSP_RIGHTGUN, "Ready.Right", nooverride:true);
		A_Overlay(PSP_LEFTGUN, "Ready.Left", nooverride:true);

		bool readyright = Right_CheckReady();
		bool readyleft = Left_CheckReady();
		// disable "rage face" if neither weapon is firing:
		if (readyright && readyleft)
		{
			player.attackdown = false;
		}

		A_WeaponReady(WRF_NOFIRE); //let the gun bob and be deselected

	}

	// Returns true if the gun is in its respective Ready state sequence
	action bool Right_CheckReady(bool left = false)
	{
		let psp = left ? Player.FindPSprite(PSP_LEFTGUN) : Player.FindPSprite(PSP_RIGHTGUN);
		let checkstate = left ? invoker.s_readyleft : invoker.s_readyRight;
		return (psp && InStateSequence(psp.curstate, checkstate));
	}
	// left-gun alias:
	action bool Left_CheckReady()
	{
		return Right_CheckReady(true);
	}

	/*	The actual raising is done via the regular A_Raise in the regular Select
		state sequence. All this function does is, it checks if the main layer
		is already in the Ready state, and if so, moves the calling layer from
		Select.Right/Select.Left to Ready.Right/Ready.Left.
	*/
	action void Right_Raise(bool left = false)
	{
		if (!player)
			return;
		let psp = player.FindPSprite(PSP_WEAPON);
		if (!psp)
			return;
		let targetState = left ? invoker.s_readyLeft : invoker.s_readyRight;
		if (InStateSequence(psp.curstate,invoker.s_ready))
		{
			player.SetPsprite(OverlayID(),targetState);
		}
	}
	//Left-gun alias:
	action void Left_Raise()
	{
		Right_Raise(true);
	}

	/* 	Ready function for the right weapon.
		Will jump into the right Fire sequence or right Reload sequence
		based on buttons pressed and ammo available.
	*/
	action void Right_WeaponReady()
	{
		if (!player)
			return;
		//Enable bobbing:
		A_OverlayFlags(OverlayID(),PSPF_ADDBOB,true);
		state targetState = null;
		bool pressingFire = player.cmd.buttons & BT_ATTACK;
		if (pressingFire)
			targetState = invoker.s_fireRight;
		//if we're going to fire/reload, disable bobbing:
		if (targetState)
		{
			A_OverlayFlags(OverlayID(),PSPF_ADDBOB,false);
			player.SetPsprite(OverlayID(),targetState);
		}
		//otherwise re-enable bobbing:
		else
		{
			A_OverlayFlags(OverlayID(),PSPF_ADDBOB,true);
		}
	}

	/* 	Ready function for the left weapon.
		Will jump into the left Fire sequence or left Reload sequence
		based on buttons pressed and ammo available.
	*/
	action void Left_WeaponReady()
	{
		if (!player)
			return;
		A_OverlayFlags(OverlayID(),PSPF_ADDBOB,true);
		state targetState = null;
		bool pressingFire = player.cmd.buttons & BT_ALTATTACK;
		if (pressingFire)
			targetState = invoker.s_fireLeft;
		if (targetState)
		{
			A_OverlayFlags(OverlayID(),PSPF_ADDBOB,false);
			player.SetPsprite(OverlayID(),targetState);
		}
		else
		{
			A_OverlayFlags(OverlayID(),PSPF_ADDBOB,true);
		}
	}

	/*	A_ReFire analog for the right gun.
		Increases player.refire just like A_Refire(), and resets it to 0
		as long as neither gun is refiring.
	*/
	action void Right_ReFire(bool left = false)
	{
		//double-check player and psp:
		if (!player)
			return;
		let psp = Player.FindPSprite(OverlayID());
		if (!psp)
			return;
		let s_fire = left ? invoker.s_fireLeft : invoker.s_fireRight; //pointer to Fire
		let s_hold = left ? invoker.s_holdLeft : invoker.s_holdRight; //pointer to Hold
		int atkbutton = left ? BT_ALTATTACK : BT_ATTACK; //check attack button is being held
		state targetState = null;
		//check if this is being called from Fire or Hold:
		if (s_fire && (InStateSequence(psp.curstate,s_fire) || InStateSequence(psp.curstate,s_hold)))
		{
			//Check if we have enough ammo and the attack button is being held:
			if (player.cmd.buttons & atkbutton && player.oldbuttons & atkbutton)
			{
				//if so, jump to Hold (if it exists) or to Fire
				targetState = s_hold ? s_hold : s_fire;
			}
		}
		//If target state was set, increase player.refire and set the state:
		if (targetState)
		{
			player.refire++;
			player.SetPsprite(OverlayID(),targetState);
		}
		//if we're not refiring...
		else
		{
			//if the OTHER gun is in its Ready sequence, reset player.refire:
			if (Right_CheckReady(left))
				player.refire = 0;
		}
	}
	action void Left_ReFire()
	{
		Right_ReFire(true);
	}

	// Attacks:
	/*	To make sure the correct ammo is consumed for each attack,
		we need to manually set invoker.bAltFire to false to consume
		primary ammo, and to true to consume secondary ammo.
		I made a bunch of simple wrappers for the generic attack
		functions.
		If you need to use a custom attack function, you'll have to set
		bAltFire manually. A_SetFireMode below can be used	for that.
	*/

	// Call this before custom attack functions to define which gun is firing
	action void A_SetFireMode(bool secondary = false)
	{
		invoker.bAltFire = secondary;
	}

	/*	These are very simple wrappers that set bAltFire to false for
		right gun and true for left gun to make sure the correct ammo
		is consumed.
	*/
	//A_CustomPunch
	action void Right_CustomPunch(int damage, bool norandom = false, int flags = CPF_USEAMMO, class<Actor> pufftype = "BulletPuff", double range = 0, double lifesteal = 0, int lifestealmax = 0, class<BasicArmorBonus> armorbonustype = "ArmorBonus", sound MeleeSound = 0, sound MissSound = "")
	{
		invoker.bAltFire = false;
		A_CustomPunch(damage, norandom, flags, pufftype, range, lifesteal, lifestealmax, armorbonustype, MeleeSound, MissSound);
	}
	action void Left_CustomPunch(int damage, bool norandom = false, int flags = CPF_USEAMMO, class<Actor> pufftype = "BulletPuff", double range = 0, double lifesteal = 0, int lifestealmax = 0, class<BasicArmorBonus> armorbonustype = "ArmorBonus", sound MeleeSound = 0, sound MissSound = "")
	{
		invoker.bAltFire = true;
		A_CustomPunch(damage, norandom, flags, pufftype, range, lifesteal, lifestealmax, armorbonustype, MeleeSound, MissSound);
	}
	Default
	{
		Weapon.SelectionOrder 3700;
		Weapon.UpSound "weapons/draw_fist";
		+INVENTORY.UNDROPPABLE
		+WEAPON.NOAUTOFIRE
		+WEAPON.NOALERT
		+WEAPON.WIMPY_WEAPON
		+WEAPON.MELEEWEAPON
		+WEAPON.NOAUTOSWITCHTO
		GWM_Fists.raisespeed 18;
		GWM_Fists.lowerspeed 18;
		Obituary "$KILLFISTS";
		Tag "Fists";
		AttackSound "weapons/punch";
	}
	States
	{
		Spawn:
			TNT1 A -1;
			Stop;
		// Normally Ready can be left as is in weapons based on this one
		Ready:
			TNT1 A 1
			{
				DualWeaponReady();
				//console.printf("primary: %d | secondary: %d",invoker.primaryAmmo.amount,invoker.secondaryAmmo.amount);
			}
			loop;
		// Fire state is required for the weapon to function but isn't used directly.
		// Do not redefine.
		Fire:
			TNT1 A 1
			{
				return ResolveState("Ready");
			}
		// AltFire state is required for the weapon to function but isn't used directly.
		// Do not redefine.
		AltFire:
			TNT1 A 1
			{
				return ResolveState("Ready");
			}
		// Normally Select can be left as is in weapons based on this one.
		// Redefine only if you want to significantly change selection animation
		Select:
			TNT1 A 0
			{
				A_overlay(PSP_RIGHTGUN, "Select.Right");
				A_Overlay(PSP_LEFTGUN, "Select.Left");
				A_OverlayFlags(PSP_LEFTGUN, PSPF_FLIP|PSPF_MIRROR, true);
			}
			TNT1 A 1 A_Raise(invoker.raisespeed);
			wait;
		// Normally Deselect can be left as is in weapons based on this one.
		// Redefine if you want to significantly change deselection animation
		Deselect:
			TNT1 A 0
			{
				A_overlay(PSP_RIGHTGUN, "Deselect.Right");
				A_Overlay(PSP_LEFTGUN, "Deselect.Left");
			}
			TNT1 A 1 A_Lower(invoker.lowerspeed);
			wait;
		/*////////////////////////
			LEFT HAND STATES
		*/////////////////////////
		Ready.Left:
			FIST C 1 Left_WeaponReady();
			Loop;
		Deselect.Left:
			FIST C 1;
			Loop;
		Select.Left:
			FIST C 1 Left_Raise();
			Loop;
		Fire.Left:
			FIST C 0 A_JumpIfInventory("PowerStrength", 1, "Fire.Left.Berserk");
		Fire1.Left:
			FIST TC 1;
			FIST D 0 A_StartSound("weapons/fistjab", CHAN_WEAPON);
			FIST G 1 A_CustomPunch(2*random(1,10), 1, 0, "BulletPuff");
		Hold.Left:
			FIST C 0 A_JumpIfInventory("PowerStrength", 1, "Hold.Left.Berserk");
			PLA3 A 0 A_JumpIf((self.Vel.X+self.Vel.Y+self.Vel.Z > 10) || (self.Vel.X+self.Vel.Y+self.Vel.Z < -10), "RunningPunch.Left");
			FIST G 1;
			FIST G 0 Left_ReFire();
			FIST FE 1;
			FIST D 1 Left_WeaponReady();
			Goto Ready.Left;
		RunningPunch.Left:
			FIST G 3 A_CustomPunch(2*random(1,10), 1, 0, "BulletPuff");
			FIST G 0 Left_ReFire();
			FIST FE 1;
			FIST D 1 Left_WeaponReady();
			Goto Ready.Left;
		Fire.Left.Berserk:
			FIST TC 1;
			FIST D 0 A_StartSound("weapons/fistjab", CHAN_WEAPON);
			FIST G 1 A_CustomPunch(2*random(25,100), 1, 0, "GWM_BerserkPuff");
		Hold.Left.Berserk:
			PLA3 A 0 A_JumpIf((self.Vel.X+self.Vel.Y+self.Vel.Z > 10) || (self.Vel.X+self.Vel.Y+self.Vel.Z < -10), "RunningBerserk.Left");
			FIST G 1;
			FIST G 0 Left_ReFire();
			FIST FE 1;
			FIST D 1 Left_WeaponReady();
			Goto Ready.Left;
		RunningBerserk.Left:
			FIST G 3 A_CustomPunch(2*random(25,100), 1, 0, "GWM_BerserkPuff");
			FIST G 0 Left_ReFire();
			FIST FE 1;
			FIST D 1 Left_WeaponReady();
			Goto Ready.Left;
		/*////////////////////////
			RIGHT HAND STATES
		*/////////////////////////
		Ready.Right:
			FIST B 1 Right_WeaponReady();
			Loop;
		Deselect.Right:
			FIST B 1;
			Loop;
		Select.Right:
			FIST B 1 Right_Raise();
			Loop;
		Fire.Right:
			FIST C 0 A_JumpIfInventory("PowerStrength", 1, "Fire.Right.Berserk");
		Fire1.Right:
			FIST TC 1;
			FIST D 0 A_StartSound("weapons/fistjab", CHAN_WEAPON);
			FIST G 1 A_CustomPunch(2*random(1,10), 1, 0, "BulletPuff");
		Hold.Right:
			FIST C 0 A_JumpIfInventory("PowerStrength", 1, "Hold.Right.Berserk");
			PLA3 A 0 A_JumpIf((self.Vel.X+self.Vel.Y+self.Vel.Z > 10) || (self.Vel.X+self.Vel.Y+self.Vel.Z < -10), "RunningPunch.Right");
			FIST G 1;
			FIST G 0 Right_ReFire();
			FIST FE 1;
			FIST D 1 Right_WeaponReady();
			Goto Ready.Right;
		RunningPunch.Right:
			FIST G 3 A_CustomPunch(2*random(1,10), 1, 0, "BulletPuff");
			FIST G 0 Right_ReFire();
			FIST FE 1;
			FIST D 1 Right_WeaponReady();
			Goto Ready.Right;
		Fire.Right.Berserk:
			FIST TC 1;
			FIST D 0 A_StartSound("weapons/fistjab", CHAN_WEAPON);
			FIST G 1 A_CustomPunch(2*random(25,100), 1, 0, "GWM_BerserkPuff");
		Hold.Right.Berserk:
			PLA3 A 0 A_JumpIf((self.Vel.X+self.Vel.Y+self.Vel.Z > 10) || (self.Vel.X+self.Vel.Y+self.Vel.Z < -10), "RunningBerserk.Right");
			FIST G 1;
			FIST G 0 Right_ReFire();
			FIST FE 1;
			FIST D 1 Right_WeaponReady();
			Goto Ready.Right;
		RunningBerserk.Right:
			FIST G 3 A_CustomPunch(2*random(25,100), 1, 0, "GWM_BerserkPuff");
			FIST G 0 Right_ReFire();
			FIST FE 1;
			FIST D 1 Right_WeaponReady();
			Goto Ready.Right;
	}
}

class GWM_BerserkPuff : Actor
{
	Default
	{
		+NOBLOCKMAP
		+NOGRAVITY
		-ALLOWPARTICLES
		-RANDOMIZE
		+PUFFONACTORS
		RenderStyle "Add";
		Alpha 0.5;
		Scale 0.65;
		VSpeed 0;
		Mass 5;
		DamageType "Rocket";
	}
	States
	{
		Spawn:
			PUFF A 4 Bright;
			PUFF BCD 4;
			Stop;
		Melee:
		XDeath:
			TNT1 A 0 {
				Radius_Quake(6, random(8,16), 0, 3, 0);
				A_StartSound("weapons/berserkhit", 6);
			}
			EXPL ABCDEFGHIJ 1 Bright A_FadeOut(0.05);
			Stop;
	}
}